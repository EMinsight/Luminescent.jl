var documenterSearchIndex = {"docs":
[{"location":"guide/#","page":"-","title":"","text":"","category":"section"},{"location":"guide/","page":"-","title":"-","text":"Engineers run simulations to improve designs. Each time the design changes, the simulation is re-run. This can be done systematically in \"parameter sweeps\" where different combinations of parameter values are simulated to determine the best design. However, this scales exponentially wrt the number of parameters or DOFs. ","category":"page"},{"location":"guide/#General-workflow","page":"-","title":"General workflow","text":"","category":"section"},{"location":"guide/","page":"-","title":"-","text":"We use gradient descent, the same as in machine learning. In lieu of optimizing neural network parameters, we're optimizing geometry (or source) parameters. In each training iteration, we generate geometry, run the simulation, calculate the objective metric, and do a backward pass to derive the gradient wrt the geometry parameters. We then do a gradient based parameter update in preparation for the next iteration.","category":"page"},{"location":"guide/","page":"-","title":"-","text":"The geometry is thus the first step. It typically has a static component which we can't change such as interfacing waveguides. Then there's a design component which we can change or optimize. The user is responsible for generating the design geometry wrt design parameters. If any pattern is allowed in the design region, our sister package Jello.jl can be used as a length scale controlled geometry generator. In any case, the result needs to be a 2d/3d array of each relevant materials property eg permitivity. ","category":"page"},{"location":"guide/","page":"-","title":"-","text":"With geometry ready, we can run the simulation. Duration is roughly the time it takes to reach steady state, such as how long it take for the signal to reach output port. The objective is usually a steady state metric which can be computed using values from the final period.  We optimize geometry for some objective. ","category":"page"},{"location":"#FDTDEngine.jl","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"Only 3d works in latest patch. 2d/1d will be fixed in future. Prerelease. Expect breaking changes","category":"page"},{"location":"#Overview","page":"FDTDEngine.jl","title":"Overview","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"Differentiable FDTD package for inverse design & topology optimization in photonics, acoustics and RF. Uses automatic differentiation by Zygote.jl for adjoint optimization. Integrates with Jello.jl to generate length scale controlled paramaterized geometry . Staggered Yee grid update with fully featured boundary conditions & sources. Customizable physics to potentially incorporate dynamics like heat transfer, charge transport.","category":"page"},{"location":"#Gallery","page":"FDTDEngine.jl","title":"Gallery","text":"","category":"section"},{"location":"#Periodic-scattering","page":"FDTDEngine.jl","title":"Periodic scattering","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"(Image: )","category":"page"},{"location":"#Quarter-wavelength-antenna","page":"FDTDEngine.jl","title":"Quarter wavelength antenna","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"(Image: )","category":"page"},{"location":"#Inverse-design-of-compact-silicon-photonic-splitter-(coming-soon)","page":"FDTDEngine.jl","title":"Inverse design of compact silicon photonic splitter (coming soon)","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"<!– (Image: ) –> <!– (Image: ) –>","category":"page"},{"location":"#Quickstart","page":"FDTDEngine.jl","title":"Quickstart","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"We do a quick 3d simulation of plane wave scattering on periodic array of dielectric spheres (first gallery movie)","category":"page"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"\"\"\"\nsimulation of plane wave scattering on periodic array of dielectric spheres\n\"\"\"\n\nusing UnPack, LinearAlgebra, GLMakie\nusing FDTDEngine\ninclude(\"$(pwd())/scripts/plot_recipes.jl\")\n\n\nF = Float32\nname = \"3d_scattering\"\nT = 4.0f0 # simulation duration in [periods]\nnres = 16\ndx = 1.0f0 / nres # pixel resolution in [wavelengths]\nCourant = 0.25f0 # Courant number\n\n\"geometry\"\nl = 2 # domain physical size length\nsz = nres .* (l, l, l) # domain voxel dimensions\nϵ1 = 1 #\nϵ2 = 2.25f0 # \nb = F.([norm(v .- sz ./ 2) < 0.5 / dx for v = Base.product(Base.oneto.(sz)...)]) # sphere\nϵ = ϵ2 * b + ϵ1 * (1 .- b)\n\n\"setup\"\nboundaries = [Periodic(2), Periodic(3)]# unspecified boundaries default to PML\n# n = [1, 0, 0]\nmonitors = []\nsources = [\n    PlaneWave(t -> cos(F(2π) * t), -1; Jz=1) # Jz excited plane wave from -x plane (eg -1)\n    # PlaneWave(t -> t < 1 ? cos(F(2π) * t) : 0.0f0, -1; Jz=1)\n]\nconfigs = setup(boundaries, sources, monitors, dx, sz; F, Courant, T)\n@unpack μ, σ, σm, dt, geometry_padding, geometry_splits, field_padding, source_effects, monitor_instances, fields, step, power = configs\n\nϵ, μ, σ, σm = apply(geometry_padding; ϵ, μ, σ, σm)\np = apply(geometry_splits; ϵ, μ, σ, σm)\nu0 = collect(values(fields))\n\n# run simulation\n@showtime sol = accumulate((u, t) -> step(u, p, t, configs), 0:dt:T, init=u0)\n\n# make movie\nEz = map(sol) do u\n    u[3]\nend\nϵz = p[1][3]\ndir = @__DIR__\nrecordsim(Ez, ϵz, configs, \"$dir/$(name)_nres_$nres.mp4\", title=\"$name\"; playback=1, bipolar=true)\n","category":"page"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"<!– (Image: m) –>","category":"page"},{"location":"#Installation","page":"FDTDEngine.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"Install via Pkg.add(url=\"https://github.com/paulxshen/FDTDEngine.jl\"). You can additionally access plotting and movie making scripts via include(\"_your_path/scripts/plot_recipes.jl\") ","category":"page"},{"location":"#Implementation","page":"FDTDEngine.jl","title":"Implementation","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"Supports 1d (Ez, Hy), 2d TMz (Ez, Hx, Hy), 2d TEz (Hz, Ex, Ey) and 3d. Length and time are in units of wavelength and period. This normalization allows usage of relative  permitivity and permeability  in equations . Fields including electric, magnetic and current density are simply bundled as a vector of arrays . Boundary conditions pad the field arrays . PML paddings are multilayered, stateful and permanent, increasing size of field and geometry arrays. All other boundaries only add transient single layers which are subsequently consumed by finite differencing  every update step. Paddings are coordinated to implictly implement staggered Yee's grid for finite differencing.","category":"page"},{"location":"#Sources","page":"FDTDEngine.jl","title":"Sources","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"If a source has fewer nonzero dimensions than the simulation domain, its signal will get normalized along its singleton dimensions. For example, all planar sources in 3d or line sources in 2d will get scaled up by a factor of 1/dx. This way, discretisation would not affect radiated power.","category":"page"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"PlaneWave\nGaussianBeam\nSource","category":"page"},{"location":"#PlaneWave","page":"FDTDEngine.jl","title":"PlaneWave","text":"function PlaneWave(f, dims; fields...)\n\nConstructs plane wave source\n\nArgs\n\nf: time function\ndims: eg -1 for wave coming from -x edge\nfields: which fields to excite & their scaling constants (typically a current source, eg Jz=1)\n\n\n\n\n\n","category":"type"},{"location":"#GaussianBeam","page":"FDTDEngine.jl","title":"GaussianBeam","text":"function GaussianBeam(f, σ, center, dims; fields...)\n\nConstructs gaussian beam source\n\nArgs\n\nf: time function\nσ: std dev length\ndims: eg 1 for x direction\nfields: which fields to excite & their scaling constants (typically a current source, eg Jz=1)\n\n\n\n\n\n","category":"type"},{"location":"#Source","page":"FDTDEngine.jl","title":"Source","text":"function Source(f, center, bounds; fields...)\nfunction Source(f, center, L::AbstractVector{<:Real}; fields...)\n\nConstructs custom centered source. Can be used to specify modal sources\n\nArgs\n\nf: time function\nL: source dimensions in [wavelengths]\nfields: which fields to excite & their scaling constants (typically a current source, eg Jz=1)\n\n\n\n\n\n","category":"type"},{"location":"#Boundaries","page":"FDTDEngine.jl","title":"Boundaries","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"Unspecified boundaries default to PML ","category":"page"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"Periodic\nPML\nPEC\nPMC","category":"page"},{"location":"#Periodic","page":"FDTDEngine.jl","title":"Periodic","text":"Periodic(dims)\n\nperiodic boundary\n\n\n\n\n\n","category":"type"},{"location":"#PML","page":"FDTDEngine.jl","title":"PML","text":"function PML(dims, d=0.25f0, σ=20.0f0)\n\nConstructs perfectly matched layers (PML aka ABC, RBC) boundary of depth d wavelengths \n\n\n\n\n\n","category":"type"},{"location":"#PEC","page":"FDTDEngine.jl","title":"PEC","text":"PEC(dims)\n\nperfect electrical conductor\n\n\n\n\n\n","category":"type"},{"location":"#PMC","page":"FDTDEngine.jl","title":"PMC","text":"PMC(dims)\n\nperfect magnetic conductor\n\n\n\n\n\n","category":"type"},{"location":"#Monitors","page":"FDTDEngine.jl","title":"Monitors","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"Monitor","category":"page"},{"location":"#Monitor","page":"FDTDEngine.jl","title":"Monitor","text":"function Monitor(span, normal=nothing)\n\nConstructs monitor which can span a point, line, surface, or volume\n\nArgs\n\nspan\nnormal: flux monitor direction\n\n\n\n\n\n","category":"type"},{"location":"#Physics","page":"FDTDEngine.jl","title":"Physics","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"step1\nstepTMz\nstepTEz\nstep3","category":"page"},{"location":"#step1","page":"FDTDEngine.jl","title":"step1","text":"function step1(u, p, t, configs)\n\nUpdates fields for 1D (Ez, Hy)\n\n\n\n\n\n","category":"function"},{"location":"#stepTMz","page":"FDTDEngine.jl","title":"stepTMz","text":"function stepTMz(u, p, t, configs)\n\nUpdates fields for 2d TMz\n\n\n\n\n\n","category":"function"},{"location":"#stepTEz","page":"FDTDEngine.jl","title":"stepTEz","text":"function stepTEz(u, p, t, configs)\n\nUpdates fields for 2d TEz (Hz, Ex, Ey)\n\n\n\n\n\n","category":"function"},{"location":"#step3","page":"FDTDEngine.jl","title":"step3","text":"function step3(u, p, t, configs)\n\nUpdates fields for 3d\n\n\n\n\n\n","category":"function"},{"location":"#Tutorials","page":"FDTDEngine.jl","title":"Tutorials","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"see examples/","category":"page"},{"location":"#Generative-inverse-design","page":"FDTDEngine.jl","title":"Generative inverse design","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"Please contact us for latest scripts.","category":"page"},{"location":"#Community","page":"FDTDEngine.jl","title":"Community","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"Discussion & updates at Julia Discourse","category":"page"},{"location":"#Contributors","page":"FDTDEngine.jl","title":"Contributors","text":"","category":"section"},{"location":"","page":"FDTDEngine.jl","title":"FDTDEngine.jl","text":"Paul Shen <pxshen@alumni.stanford.edu>","category":"page"}]
}
