var documenterSearchIndex = {
    "docs":
        [{ "location": "guide/#", "page": "-", "title": "", "text": "", "category": "section" }, { "location": "guide/", "page": "-", "title": "-", "text": "Engineers run simulations to improve designs. Each time the design changes, the simulation is re-run. This can be done systematically in \"parameter sweeps\" where different combinations of parameter values are simulated to determine the best design. However, this scales exponentially wrt the number of parameters or DOFs. ", "category": "page" }, { "location": "guide/#General-workflow", "page": "-", "title": "General workflow", "text": "", "category": "section" }, { "location": "guide/", "page": "-", "title": "-", "text": "We use gradient descent, the same as in machine learning. In lieu of optimizing neural network parameters, we're optimizing geometry (or source) parameters. In each training iteration, we generate geometry, run the simulation, calculate the objective metric, and do a backward pass to derive the gradient wrt the geometry parameters. We then do a gradient based parameter update in preparation for the next iteration.", "category": "page" }, { "location": "guide/", "page": "-", "title": "-", "text": "The geometry is thus the first step. It typically has a static component which we can't change such as interfacing waveguides. Then there's a design component which we can change or optimize. The user is responsible for generating the design geometry wrt design parameters. If any pattern is allowed in the design region, our sister package Jello.jl can be used as a length scale controlled geometry generator. In any case, the result needs to be a 2d/3d array of each relevant materials property eg permitivity. ", "category": "page" }, { "location": "guide/", "page": "-", "title": "-", "text": "With geometry ready, we can run the simulation. Duration is roughly the time it takes to reach steady state, such as how long it take for the signal to reach output port. The objective is usually a steady state metric which can be computed using values from the final period.  We optimize geometry for some objective. ", "category": "page" }, { "location": "#FDTDEngine.jl", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "Prerelease. Expect breaking changes", "category": "page" }, { "location": "#Overview", "page": "FDTDEngine.jl", "title": "Overview", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "Differentiable FDTD package for inverse design & topology optimization in photonics, acoustics and RF. Uses automatic differentiation by Zygote.jl for adjoint optimization. Integrates with Jello.jl to generate length scale controlled paramaterized geometry . Staggered Yee grid update with fully featured boundary conditions & sources. Customizable physics to potentially incorporate dynamics like heat transfer, charge transport.", "category": "page" }, { "location": "#Quickstart", "page": "FDTDEngine.jl", "title": "Quickstart", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "We do a quick 2d simulation of plane wave on periodic array of dielectric pillars in front of metal of plane (Image: )", "category": "page" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "name = \"periodic_array\"\nusing UnPack,FDTDEngine\ninclude(\"examples/utils/plot_recipes.jl\")\n\n\"simulation params\"\nT = 20.0f0 # simulation duration in [periods]\nnres = 32\nCourant = 0.5f0 # Courant number\nF = Float32\n\n\"recording params\"\nframeat = 1 / 16 # captures frame every _ periods\nframerate = 16 # playback speed\n\ndx = 1.0f0 / nres # pixel resolution in [wavelengths]\nL = F[8, 8] # domain dimensions in [wavelengths]\n\n# setup FDTD\npolarization = :TMz\nboundaries = [Periodic(2), PEC(1)] # unspecified boundaries default to PML\nmonitors = [Monitor([L / 2])]\nsources = [PlaneWave(t -> exp(-((t - 1) / 1)^2) * cos(F(2π) * t), -1; Jz=1)]\nfdtd_configs = setup(boundaries, sources, monitors, L, dx, polarization; F, Courant, T)\n@unpack esz0, hsz0, dt, geometry_padding, field_padding, source_effects, monitor_instances, fields = fdtd_configs\n\nϵ1 = 1 #\nϵ2 = 2.25f0 # \nb = F.([norm([x, y] .- esz0 ./ 2) < 1 / dx for x = 1:esz0[1], y = 1:esz0[2]]) # circle\n\nϵ = ϵ2 * b + ϵ1 * (1 .- b)\nμ = ones(F, hsz0)\nσ = zeros(F, esz0)\nσm = zeros(F, hsz0)\nϵ, μ, σ, σm = apply(geometry_padding; ϵ, μ, σ, σm)\n\np = [ϵ, μ, σ, σm]\nu0 = collect(values(fields))\n\n# run & record simulation\n@showtime sol = accumulate((u, t) -> stepTMz(u, p, t, fdtd_configs), 0:dt:T, init=u0)\nrecordsim(sol, p, fdtd_configs, \"$(name)_nres_$nres.mp4\", title=\"$name\"; frameat, framerate)", "category": "page" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "<!– (Image: m) –>", "category": "page" }, { "location": "#Installation", "page": "FDTDEngine.jl", "title": "Installation", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "Install via Pkg.add(url=\"https://github.com/paulxshen/differentiable-fdtd-beta-prerelease\"). You can additionally access plotting and movie making scripts via include(\"examples/utils/plot_recipes.jl\") (may need to modify path)", "category": "page" }, { "location": "#Implementation", "page": "FDTDEngine.jl", "title": "Implementation", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "Supports 1d (Ez, Hy), 2d TMz (Ez, Hx, Hy), 2d TEz (Hz, Ex, Ey) and 3d. Length and time are in units of wavelength and period. This normalization allows usage of relative  permitivity and permeability  in equations . Fields including electric, magnetic and current density are simply bundled as a vector of arrays . Boundary conditions pad the field arrays . PML paddings are multilayered, stateful and permanent, increasing size of field and geometry arrays. All other boundaries only add transient single layers which are subsequently consumed by finite differencing  every update step. Paddings are coordinated to implictly implement staggered Yee's grid for finite differencing.", "category": "page" }, { "location": "#Sources", "page": "FDTDEngine.jl", "title": "Sources", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "PlaneWave\nGaussianBeam\nUniformSource\nSource", "category": "page" }, { "location": "#Main.FDTDEngine.PlaneWave", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.PlaneWave", "text": "function PlaneWave(f, dims; fields...)\n\nConstructs plane wave source\n\nArgs\n\nf: time function\ndims: eg -1 for wave coming from -x edge\nfields: which fields to excite & their scaling constants (typically a current source, eg Jz=1)\n\n\n\n\n\n", "category": "type" }, { "location": "#Main.FDTDEngine.GaussianBeam", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.GaussianBeam", "text": "function GaussianBeam(f, σ, center, dims; fields...)\n\nConstructs gaussian beam source\n\nArgs\n\nf: time function\nσ: std dev length\ndims: eg 1 for x direction\nfields: which fields to excite & their scaling constants (typically a current source, eg Jz=1)\n\n\n\n\n\n", "category": "type" }, { "location": "#Main.FDTDEngine.UniformSource", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.UniformSource", "text": "function UniformSource(f, lengths, center; fields...)\n\nConstructs uniform source\n\nArgs\n\nf: time function\nfields: which fields to excite & their scaling constants (typically a current source, eg Jz=1)\n\n\n\n\n\n", "category": "type" }, { "location": "#Main.FDTDEngine.Source", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.Source", "text": "function Source(f, g, center, L; fields...)\n\nConstructs custom centered source. Can be used to specify modal sources\n\nArgs\n\nf: time function\ng: spatial function\nL: source dimensions in [wavelengths]\nfields: which fields to excite & their scaling constants (typically a current source, eg Jz=1)\n\n\n\n\n\n", "category": "type" }, { "location": "#Boundaries", "page": "FDTDEngine.jl", "title": "Boundaries", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "Unspecified boundaries default to PML ", "category": "page" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "Periodic\nPML\nPEC\nPMC", "category": "page" }, { "location": "#Main.FDTDEngine.Periodic", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.Periodic", "text": "Periodic(dims)\n\nperiodic boundary\n\n\n\n\n\n", "category": "type" }, { "location": "#Main.FDTDEngine.PML", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.PML", "text": "function PML(dims, d=0.5f0, σ=8.0f0)\n\nConstructs perfectly matched layers (PML aka ABC, RBC) boundary of depth d wavelengths \n\n\n\n\n\n", "category": "type" }, { "location": "#Main.FDTDEngine.PEC", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.PEC", "text": "PEC(dims)\n\nperfect electrical conductor\n\n\n\n\n\n", "category": "type" }, { "location": "#Main.FDTDEngine.PMC", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.PMC", "text": "PMC(dims)\n\nperfect magnetic conductor\n\n\n\n\n\n", "category": "type" }, { "location": "#Monitors", "page": "FDTDEngine.jl", "title": "Monitors", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "Monitor", "category": "page" }, { "location": "#Main.FDTDEngine.Monitor", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.Monitor", "text": "function Monitor(span, normal=nothing)\n\nConstructs monitor which can span a point, line, surface, or volume\n\nArgs\n\nspan\nnormal: flux monitor direction\n\n\n\n\n\n", "category": "type" }, { "location": "#Physics", "page": "FDTDEngine.jl", "title": "Physics", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "step1\nstepTMz\nstepTEz\nstep3", "category": "page" }, { "location": "#Main.FDTDEngine.step1", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.step1", "text": "function step1(u, p, t, configs)\n\nUpdates fields for 1D (Ez, Hy)\n\n\n\n\n\n", "category": "function" }, { "location": "#Main.FDTDEngine.stepTMz", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.stepTMz", "text": "function stepTMz(u, p, t, configs)\n\nUpdates fields for 2d TMz\n\n\n\n\n\n", "category": "function" }, { "location": "#Main.FDTDEngine.stepTEz", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.stepTEz", "text": "function stepTEz(u, p, t, configs)\n\nUpdates fields for 2d TEz (Hz, Ex, Ey)\n\n\n\n\n\n", "category": "function" }, { "location": "#Main.FDTDEngine.step3", "page": "FDTDEngine.jl", "title": "Main.FDTDEngine.step3", "text": "function step3(u, p, t, configs)\n\nUpdates fields for 3d\n\n\n\n\n\n", "category": "function" }, { "location": "#Tutorials", "page": "FDTDEngine.jl", "title": "Tutorials", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "Hosted on Google Colab simulation", "category": "page" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "2dperiodicarray", "category": "page" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "inverse_design", "category": "page" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "2dwaveguidebend", "category": "page" }, { "location": "#TODO", "page": "FDTDEngine.jl", "title": "TODO", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "integration with external mode solver (suggestions welcome ) for modal source profiles \nfar field transforms\nyour wonderful suggestion ;)", "category": "page" }, { "location": "#Community", "page": "FDTDEngine.jl", "title": "Community", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "Discussion & updates at Julia Discourse", "category": "page" }, { "location": "#Contributors", "page": "FDTDEngine.jl", "title": "Contributors", "text": "", "category": "section" }, { "location": "", "page": "FDTDEngine.jl", "title": "FDTDEngine.jl", "text": "Paul Shen <pxshen@alumni.stanford.edu>", "category": "page" }]
}
